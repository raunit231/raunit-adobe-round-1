/* These lines of code are importing necessary modules and libraries for the JavaScript program. */
const PDFServiceSdk = require("@adobe/pdfservices-node-sdk");
const fs = require('fs');
const AdmZip = require("adm-zip");
const createCsvWriter = require('csv-writer').createObjectCsvWriter;




/* These lines of code are creating a CSV writer object using the `csv-writer` library.csvHeader contains the header of the csv file */
const csvHeader = [
  { id: 'bussinessCity', title: 'Bussiness__City' },
  { id: 'bussinessCountry', title: 'Bussiness__Country' },
  { id: 'bussinessDescription', title: 'Bussiness__Description' },
  { id: 'bussinessName', title: 'Bussiness__Name' },
  { id: 'bussinessStreetAddress', title: 'Bussiness__StreetAddress' },
  { id: 'bussinessZipcode', title: 'Bussiness__Zipcode' },
  { id: 'customerAddressLine1', title: 'Customer__Address__line1' },
  { id: 'customerAddressLine2', title: 'Customer__Address__line2' },
  { id: 'customerEmail', title: 'Customer__Email' },
  { id: 'customerName', title: 'Customer__Name' },
  { id: 'customerPhoneNumber', title: 'Customer__PhoneNumber' },
  { id: 'invoiceBillDetailsName', title: 'Invoice__BillDetails__Name' },
  { id: 'invoiceBillDetailsQuantity', title: 'Invoice__BillDetails__Quantity' },
  { id: 'invoiceBillDetailsRate', title: 'Invoice__BillDetails__Rate' },
  { id: 'invoiceDescription', title: 'Invoice__Description' },
  { id: 'invoiceDueDate', title: 'Invoice__DueDate' },
  { id: 'invoiceIssueDate', title: 'Invoice__IssueDate' },
  { id: 'invoiceNumber', title: 'Invoice__Number' },
  { id: 'invoiceTax', title: 'Invoice__Tax' },
];
const csvWriter = createCsvWriter({
  path: './FinalExtractedData.csv',
  header: csvHeader,
});



/**
 * The function extracts text from a PDF file and returns it as a JavaScript object.
 * @param inputPdfFilePath - The file path of the input PDF file that needs to be processed.
 * @returns a JavaScript object that contains the extracted text data from a PDF file. The text data is
 * parsed from a JSON file that is generated by the PDF Services SDK.
 */
const extractJsonObjectFromPdf = async (inputPdfFilePath) => {


  try {

    /* The below code is checking if a file named "ExtractTextFromPDF.zip" exists in the current
    directory. If it exists, it is deleted using the `fs.unlinkSync()` method. */
    const OutputZip = './ExtractTextFromPDF.zip';
    if (fs.existsSync(OutputZip)) fs.unlinkSync(OutputZip);


    // sdk credential setup
    const credentials = PDFServiceSdk.Credentials.serviceAccountCredentialsBuilder().fromFile('pdfservices-api-credentials.json')
      .build();

    // create an executionContext using credentials
    const executionContext = PDFServiceSdk.ExecutionContext.create(credentials);

    // create a new operation instance
    const extractPDFOperation = PDFServiceSdk.ExtractPDF.Operation.createNew()
    const input = PDFServiceSdk.FileRef.createFromLocalFile(inputPdfFilePath, PDFServiceSdk.ExtractPDF.SupportedSourceFormat.pdf);

    // Build extractPDF options
    const options = new PDFServiceSdk.ExtractPDF.options.ExtractPdfOptions.Builder()
      .addElementsToExtract(PDFServiceSdk.ExtractPDF.options.ExtractElementType.TEXT).build();

    // Set operation input from a source file
    extractPDFOperation.setInput(input);
    // Set options
    extractPDFOperation.setOptions(options);
    //** Execute the operation */
    const result = await extractPDFOperation.execute(executionContext);
    //saving the result 
    await result.saveAsFile(OutputZip);
    try {
      /* These lines of code are reading the contents of a zip file generated by the PDF Services SDK.
      The `AdmZip` library is used to create a new instance of a zip file object, which is then used
      to read the contents of a specific file within the zip archive. The `readAsText` method is
      used to read the contents of the `structuredData.json` file within the zip archive and store
      it in the `jsonData` variable. The `JSON.parse` method is then used to parse the JSON data
      into a JavaScript object, which is stored in the `data` variable. Finally, the `data` object
      is returned from the `extractJsonFromPdf` function. */
      let zip = new AdmZip(OutputZip);
      let jsonData = zip.readAsText("structuredData.json");
      let data = JSON.parse(jsonData);

      return data;
    } catch (err) {
      console.log(`Exception encountered while reading zip file of ${inputPdfFilePath}`, err);
    }

  } catch (err) {
    console.log(`Exception encountered while executing operation of ${inputPdfFilePath}`, err);
  }

};


const writeDataFromJsonToCSV = async (inputPdfFilePath) => {
  try {

    const jsonData = await extractJsonObjectFromPdf(inputPdfFilePath);
    const { elements } = jsonData;
    const input = {};
    var indexOfBillTo, indexOfDetails, indexOfPayment, indexOfInvoice, indexOfTitle, indexOfItem, indexOfSubtotal, indexOfTax, indexOfTotalDue;
    var bussinessAddressData = [], invoiceTableData = [], customerDetailsData = [], bussinessDescriptionData = [];

    elements.forEach((element, index) => {
      if (element.Text) {
        let { Path, Text } = element;
        if (Path.includes("/Title") || element.TextSize > 24) {
          //saving the title and index of title element
          indexOfTitle = index;
          let bussinessNameValue = Text.trim();
          input.bussinessName = bussinessNameValue;
        }
        if (Text.includes("BILL TO")) {
          //saving index of bill to element
          indexOfBillTo = index;
        }

        if (Text.includes("DETAILS")) {
          //saving index of details element
          indexOfDetails = index;
        }
        if (Text.includes("PAYMENT")) {
          //saving index of payment element
          indexOfPayment = index;
        }
        if (Text.includes("Due date")) {
          // saving invoice due date
          let startingIndex = Text.indexOf("Due date:") + "Due date:".length;
          let invoiceDueDateValue = Text.slice(startingIndex, Text.length).trim();
          input.invoiceDueDate = invoiceDueDateValue;
        }
        if (Text.includes("Invoice#")) {
          //saving index of invoice element
          indexOfInvoice = index;
        }

        if (Text.includes("ITEM")) {
          //saving index of item element
          indexOfItem = index;
        }
        if (Text.includes("Subtotal")) {
          //saving index of subtotal element
          indexOfSubtotal = index;
        }
        if (Text.includes("Tax %")) {
          //saving index of tax element
          indexOfTax = index;
        }
        if (Text.includes("Total Due")) {
          //saving index of total due element
          indexOfTotalDue = index;
        }

      }
    });
    // extracting the text till invoice element for the extraction of bussiness address
    for (let index = 0; index < indexOfInvoice; index++) {
      if (elements[index].Text) {
        let { Text } = elements[index];
        bussinessAddressData.push(Text.trim());
      }
    }

    // extracting the text between invoice and title element for the extraction of invoice number,invoice issue date
    var valueBetweenInvoiceAndTitle = "";
    for (let index = indexOfInvoice; index < indexOfTitle; index++) {
      if (elements[index].Text) {
        valueBetweenInvoiceAndTitle += elements[index].Text;
      }
    }
    //extracting invoice number and issue date
    let invoiceNumberValue = valueBetweenInvoiceAndTitle.slice(valueBetweenInvoiceAndTitle.indexOf(" "), valueBetweenInvoiceAndTitle.indexOf("Issue")).trim();
    let invoiceIssueDateValue = valueBetweenInvoiceAndTitle.slice(valueBetweenInvoiceAndTitle.indexOf("Issue date") + "Issue date".length).trim();
    //saving invoice number, issue date
    [input.invoiceNumber, input.invoiceIssueDate] = [invoiceNumberValue, invoiceIssueDateValue];

    // extracting and storing bussiness description 
    for (let index = indexOfTitle + 1; index < indexOfBillTo; index++) {
      if (elements[index].Text) {
        let { Text } = elements[index];
        bussinessDescriptionData.push(Text.trim());
      }
    }
    input.bussinessDescription = bussinessDescriptionData[0];


    //extracting invoice description
    const invoiceDescriptionFinal = [];
    for (let i = indexOfBillTo; i < indexOfItem; i++) {
      if (elements[i].Text && elements[i].Bounds) {
        const { Bounds, Text } = elements[i];
        if (Bounds[0] > (elements[indexOfDetails].Bounds[0] - 10) && Bounds[0] < elements[indexOfPayment].Bounds[0] - 10) {
          invoiceDescriptionFinal.push(Text);
        }
        if (Bounds[0] > (elements[indexOfBillTo].Bounds[0] - 10) && Bounds[0] < elements[indexOfDetails].Bounds[0] - 10) {
          customerDetailsData.push(Text.trim());
        }
      }
    }
    customerDetailsData.shift();
    var invoiceDescriptionValue = "";
    invoiceDescriptionFinal.forEach(text => {
      if (!text.includes("DETAILS")) {
        invoiceDescriptionValue += text;
      }
    });
    //saving invoice description
    input.invoiceDescription = invoiceDescriptionValue.trim();




    // extracting invoice table data
    for (let index = indexOfItem; index < indexOfSubtotal; index++) {
      if (elements[index].Text) {
        let { Text } = elements[index];
        invoiceTableData.push(Text.trim());
      }
    }

    // extracting invoice tax on the basis of left value of bounds
    for (let index = indexOfSubtotal; index < indexOfTotalDue; index++) {
      if (elements[index].Text && elements[index].Bounds && elements[indexOfTax]) {
        if (elements[index].Bounds[1] === elements[indexOfTax].Bounds[1] && index !== indexOfTax) {
          let { Text } = elements[index];
          input.invoiceTax = Text.trim();
        }
      }
    }
    // incase of failed extraction of invoice tax, trying to extract again
    if (!input.invoiceTax && elements[indexOfTax]) {
      if (elements[indexOfTax].Text) {
        var { Text } = elements[indexOfTax];
        if (Text.includes("Tax %") && Text.trim().length !== "Tax %".length) {
          input.invoiceTax = Text.slice(Text.indexOf("Tax %") + "Tax %".length).trim();
        }
      }
    }


    /* extracting bussiness address and dealing with the case when api reads the both bussiness address lines in one line */
    const bussinessAddress = bussinessAddressData[1].split(",");
    if (bussinessAddress.length === 3) {
      input.bussinessStreetAddress = bussinessAddress[0].trim();
      input.bussinessCity = bussinessAddress[1].trim();
      input.bussinessCountry = bussinessAddressData[2];
      input.bussinessZipcode = bussinessAddressData[3];
    } else {
      input.bussinessStreetAddress = bussinessAddress[0].trim();
      input.bussinessCity = bussinessAddress[1].trim();
      input.bussinessCountry = bussinessAddress[2].trim() + ", " + bussinessAddress[3].trim();
      input.bussinessZipcode = bussinessAddressData[2];
    }





    
    /* The below code is processing customer details data in case when api reads multile lines in pdf together in one element. It checks if the data contains an email
    address and if the length of the data is greater than 25 characters. If it meets these
    conditions, it splits the data into customer name and email address and adds them to a temporary
    array. If the data does not contain an email address but has a length greater than or equal to
    22 characters, it splits the data into customer address line 1 and customer address line 2 and
    adds them to the temporary array. If the data does not meet any of these conditions, it adds the
    data to the temporary */
    const temporaryCustomerDetailsData = [];
    customerDetailsData.forEach((data) => {
      if ((data.trim().length > 25) && data.includes("@")) {
        const temporaryData = data.split(" ");
        const mailIndex = temporaryData.findIndex((x) => x.includes("@"));
        let tempCustomerName = "";
        for (let i = 0; i < mailIndex; i++) {
          tempCustomerName += temporaryData[i] + " ";
        }
        temporaryCustomerDetailsData.push(tempCustomerName.trim());
        for (let i = mailIndex; i < temporaryData.length; i++) {
          temporaryCustomerDetailsData.push(temporaryData[i]);
        }
      }
      else if (data.trim().length >= 22 && !data.includes("@")) {
        const temporaryData = data.split(" ");
        let tempCustomerAddress = "";
        let i = 0;
        if (temporaryData[0].includes("-")) {
          temporaryCustomerDetailsData.push(temporaryData[0].trim());
          i++;
        }
        while ((tempCustomerAddress + temporaryData[i]).trim().length < 22) {
          tempCustomerAddress += temporaryData[i] + " ";
          i++;
        }
        temporaryCustomerDetailsData.push(tempCustomerAddress.trim());
        let tempCustomerAddress2 = "";
        while (i < temporaryData.length) {
          tempCustomerAddress2 += temporaryData[i] + " ";
          i++;
        }
        temporaryCustomerDetailsData.push(tempCustomerAddress2.trim());
      } else {
        temporaryCustomerDetailsData.push(data.trim());
      }
    })
    if (temporaryCustomerDetailsData.length > 2) {
      customerDetailsData = temporaryCustomerDetailsData;
    }


    /* The below code is taking in an array of customer details data and assigning specific values to
    input variables for customer name, email, phone number, and address lines 1 and 2. It checks if
    the customer email is valid and if not, appends the missing part to the email value. It then
    extracts the phone number and address lines 1 and 2 from the customer details data array. The
    address lines are split based on a maximum length of 20 characters per line (in case api reads multiple pdf lines together). Finally, the
    extracted values are assigned to the corresponding input variables. */
    input.customerName = customerDetailsData[0];
    let customerEmailValue = customerDetailsData[1], customerPhoneNumberValue, customerAddressLine1Value, customerAddressLine2Value;
    if (customerEmailValue !== null && !customerEmailValue.includes(".com")) {
      customerEmailValue += customerDetailsData[2];
      customerPhoneNumberValue = customerDetailsData[3];
      let tempCustomerAddress = "";
      let i = 4;
      while ((tempCustomerAddress + customerDetailsData[i]).trim().length <= 20) {
        tempCustomerAddress += customerDetailsData[i] + " ";
        i++;
      }
      customerAddressLine1Value = tempCustomerAddress.trim();
      tempCustomerAddress = "";
      while (i < customerDetailsData.length) {
        tempCustomerAddress += customerDetailsData[i] + " ";
        i++;
      }
      customerAddressLine2Value = tempCustomerAddress.trim();
    } else {
      customerPhoneNumberValue = customerDetailsData[2];
      let tempCustomerAddress = "";
      let i = 3;
      while ((tempCustomerAddress + customerDetailsData[i]).trim().length <= 20) {
        tempCustomerAddress += customerDetailsData[i] + " ";
        i++;
      }
      customerAddressLine1Value = tempCustomerAddress.trim();
      tempCustomerAddress = "";
      while (i < customerDetailsData.length) {
        tempCustomerAddress += customerDetailsData[i] + " ";
        i++;
      }
      customerAddressLine2Value = tempCustomerAddress.trim();
    }
    [input.customerEmail, input.customerPhoneNumber, input.customerAddressLine1, input.customerAddressLine2] = [customerEmailValue, customerPhoneNumberValue, customerAddressLine1Value, customerAddressLine2Value];



    //saving invoice table data and writing whole row data to CSV file
    let idx = 4;
    while (idx < invoiceTableData.length) {
      input.invoiceBillDetailsName = invoiceTableData[idx];
      input.invoiceBillDetailsQuantity = invoiceTableData[idx + 1];
      input.invoiceBillDetailsRate = invoiceTableData[idx + 2];
      // console.log(input);
      try {
        await csvWriter.writeRecords([input]);
        // console.log(`Row ${idx / 4} Data of ${inputPdfFilePath} written Successfully in CSV file`);
      } catch (err) {
        console.log(`Exception encountered while writing data of ${inputPdfFilePath} in CSV file `, err);
      }
      idx += 4;
    }
  } catch (err) {
    console.log(`Exception encountered while writing data from json operation of ${inputPdfFilePath}`, err);
  }

}



const extractDataFromEachFile = async () => {
  let inputFileIndex = 0;
  while (inputFileIndex < 100) {
    try {
      const inputPdfFilePath = `./resources/TestDataSet/output${inputFileIndex}.pdf`;
      await writeDataFromJsonToCSV(inputPdfFilePath);
      console.log(`Data of ${inputPdfFilePath} written Successfully in CSV file`);
    } catch (error) {
      console.log(error);
    }
    inputFileIndex++;
  }
}

extractDataFromEachFile();